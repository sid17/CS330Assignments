// machine.cc 
//	Routines for simulating the execution of user programs.
//
//  DO NOT CHANGE -- part of the machine emulation
//
// Copyright (c) 1992-1993 The Regents of the University of California.
// All rights reserved.  See copyright.h for copyright notice and limitation 
// of liability and disclaimer of warranty provisions.

#include "copyright.h"
#include "machine.h"
#include "system.h"
#include <time.h>

// Textual names of the exceptions that can be generated by user program
// execution, for debugging.
static char* exceptionNames[] = { "no exception", "syscall", 
				"page fault/no TLB entry", "page read only",
				"bus error", "address error", "overflow",
				"illegal instruction" };

//----------------------------------------------------------------------
// CheckEndian
// 	Check to be sure that the host really uses the format it says it 
//	does, for storing the bytes of an integer.  Stop on error.
//----------------------------------------------------------------------

static
void CheckEndian()
{
    union checkit {
        char charword[4];
        unsigned int intword;
    } check;

    check.charword[0] = 1;
    check.charword[1] = 2;
    check.charword[2] = 3;
    check.charword[3] = 4;

#ifdef HOST_IS_BIG_ENDIAN
    ASSERT (check.intword == 0x01020304);
#else
    ASSERT (check.intword == 0x04030201);
#endif
}

//----------------------------------------------------------------------
// Machine::Machine
// 	Initialize the simulation of user program execution.
//
//	"debug" -- if TRUE, drop into the debugger after each user instruction
//		is executed.
//----------------------------------------------------------------------

Machine::Machine(bool debug)
{
    int i;

    for (i = 0; i < NumTotalRegs; i++)
        registers[i] = 0;
    mainMemory = new char[MemorySize];
    for (i = 0; i < MemorySize; i++)
      	mainMemory[i] = 0;

for (i=0;i<NumPhysPages;i++)
{
     mainMemoryStatus[i]=-2;
}
   

#ifdef USE_TLB
    tlb = new TranslationEntry[TLBSize];
    for (i = 0; i < TLBSize; i++)
	tlb[i].valid = FALSE;
    pageTable = NULL;
#else	// use linear page table
    tlb = NULL;
    pageTable = NULL;
#endif

    singleStep = debug;
    CheckEndian();
}

//----------------------------------------------------------------------
// Machine::~Machine
// 	De-allocate the data structures used to simulate user program execution.
//----------------------------------------------------------------------

Machine::~Machine()
{
    delete [] mainMemory;
    if (tlb != NULL)
        delete [] tlb;
}

//----------------------------------------------------------------------
// Machine::RaiseException
// 	Transfer control to the Nachos kernel from user mode, because
//	the user program either invoked a system call, or some exception
//	occured (such as the address translation failed).
//
//	"which" -- the cause of the kernel trap
//	"badVaddr" -- the virtual address causing the trap, if appropriate
//----------------------------------------------------------------------

void
Machine::RaiseException(ExceptionType which, int badVAddr)
{
    DEBUG('m', "Exception: %s\n", exceptionNames[which]);
    
//  ASSERT(interrupt->getStatus() == UserMode);
    registers[BadVAddrReg] = badVAddr;
    DelayedLoad(0, 0);			// finish anything in progress
    interrupt->setStatus(SystemMode);
    ExceptionHandler(which);		// interrupts are enabled at this point
    interrupt->setStatus(UserMode);
}

//----------------------------------------------------------------------
// Machine::Debugger
// 	Primitive debugger for user programs.  Note that we can't use
//	gdb to debug user programs, since gdb doesn't run on top of Nachos.
//	It could, but you'd have to implement *a lot* more system calls
//	to get it to work!
//
//	So just allow single-stepping, and printing the contents of memory.
//----------------------------------------------------------------------

void Machine::Debugger()
{
    char *buf = new char[80];
    int num;

    interrupt->DumpState();
    DumpState();
    printf("%d> ", stats->totalTicks);
    fflush(stdout);
    fgets(buf, 80, stdin);
    if (sscanf(buf, "%d", &num) == 1)
	runUntilTime = num;
    else {
	runUntilTime = 0;
	switch (*buf) {
	  case '\n':
	    break;
	    
	  case 'c':
	    singleStep = FALSE;
	    break;
	    
	  case '?':
	    printf("Machine commands:\n");
	    printf("    <return>  execute one instruction\n");
	    printf("    <number>  run until the given timer tick\n");
	    printf("    c         run until completion\n");
	    printf("    ?         print help message\n");
	    break;
	}
    }
    delete [] buf;
}
 
//----------------------------------------------------------------------
// Machine::DumpState
// 	Print the user program's CPU state.  We might print the contents
//	of memory, but that seemed like overkill.
//----------------------------------------------------------------------

void
Machine::DumpState()
{
    int i;
    
    printf("Machine registers:\n");
    for (i = 0; i < NumGPRegs; i++)
	switch (i) {
	  case StackReg:
	    printf("\tSP(%d):\t0x%x%s", i, registers[i],
		   ((i % 4) == 3) ? "\n" : "");
	    break;
	    
	  case RetAddrReg:
	    printf("\tRA(%d):\t0x%x%s", i, registers[i],
		   ((i % 4) == 3) ? "\n" : "");
	    break;
	  
	  default:
	    printf("\t%d:\t0x%x%s", i, registers[i],
		   ((i % 4) == 3) ? "\n" : "");
	    break;
	}
    
    printf("\tHi:\t0x%x", registers[HiReg]);
    printf("\tLo:\t0x%x\n", registers[LoReg]);
    printf("\tPC:\t0x%x", registers[PCReg]);
    printf("\tNextPC:\t0x%x", registers[NextPCReg]);
    printf("\tPrevPC:\t0x%x\n", registers[PrevPCReg]);
    printf("\tLoad:\t0x%x", registers[LoadReg]);
    printf("\tLoadV:\t0x%x\n", registers[LoadValueReg]);
    printf("\n");
}

//----------------------------------------------------------------------
// Machine::ReadRegister/WriteRegister
//   	Fetch or write the contents of a user program register.
//----------------------------------------------------------------------

int Machine::ReadRegister(int num)
    {
	ASSERT((num >= 0) && (num < NumTotalRegs));
	return registers[num];
    }

void Machine::WriteRegister(int num, int value)
    {
	ASSERT((num >= 0) && (num < NumTotalRegs));
	// DEBUG('m', "WriteRegister %d, value %d\n", num, value);
	registers[num] = value;
    }


int Machine::getMainMemoryPage(int code,int p)
{
    int i;
    int final_page=-1;
    for (i=0;i<NumPhysPages;i++)
    {

        if (mainMemoryStatus[i]==-2)
        {
        final_page=i;
        break;
        }
    }
   // if(pageReplacementAlgo==3)
   // {
   //      printlist (lru_algo);	
   //     printf("\n p is %d\n",p);
   // }
    if (p!=-1 && pageReplacementAlgo==3)
    {
         deleted(lru_algo,lru_arr[p]);
         insertd(lru_algo,lru_arr[p]);
	 //     pg1=lru_algo->tail->val;
      //   deleted(lru_algo,lru_arr[pg1]);

    }
    if (final_page==-1)
    {
    
    int pg=PageReplacementAlgorithm(p);

   // printf("Pg is %d %d %d\n",pg,threadArray[mainMemoryStatus[pg]]->GetPID(),mainMemoryStatus[pg]);
    (threadArray[mainMemoryStatus[pg]]->space)->unsetPageTableEntry(pg,threadArray[mainMemoryStatus[pg]]->GetPID());
    //printf("\nthis belongs to the page stats: %d   pid:%d \n",machine->mainMemoryStatus[pg],pg);
    final_page=pg;
    }
    machine->mainMemoryStatus[final_page]=code;
    bzero(&machine->mainMemory[final_page*PageSize], PageSize);

    //printf("Inserted %d\n",final_page);
    if(code!=-1)
    {

        if (pageReplacementAlgo==2)
        {
            // int *x = new int();
            // *x = final_page;
            // // printf("Inserted %d\n",final_page);
            // fifoQueue->Append((void *)x);

            insertd(fifoQueue,fifo_arr[final_page]); 
            
        }
        
        if (pageReplacementAlgo==3)
        {
           ASSERT(lru_arr[final_page]->val<NumPhysPages);
           insertd(lru_algo,lru_arr[final_page]); 
//	 printlist (lru_algo);	
//	printf("\n p is %d\n",p);
        }

        if (pageReplacementAlgo==4)
        {
        if (p!=-1)
        {
             arr_LruClock[final_page]=1;
	         arr_LruClock[p]=1;
        }
        else
        {
            arr_LruClock[final_page]=1;
        }
       
        
        }


    }

    NumPageFaults=NumPageFaults+1;
    return final_page;


}

void Machine::freeMainMemory(int id)
{
    machine->mainMemoryStatus[id]=-2; 

}


int Machine::PageReplacementAlgorithm(int p)
{


   


if (pageReplacementAlgo==1)
{
    int pg=Random()%NumPhysPages;
    while (pg==p || mainMemoryStatus[pg]==-1)
    {
      pg=Random()%NumPhysPages;
    }

    //printf("Random is %d\n",pg);
     return pg;
}
else if (pageReplacementAlgo==2)
{

    int pg,pg1;
    pg=fifoQueue->tail->val;
    //deleted(fifoQueue,fifo_arr[pg]);
    if (p!=-1 && pg==p)
    {
        pg1=fifo_arr[pg]->prev->val;
        deleted(fifoQueue,fifo_arr[pg1]);

    }
    else
    {
        pg1=fifo_arr[pg]->val;
        deleted(fifoQueue,fifo_arr[pg1]);
    }


    
    return pg1;
}
else if (pageReplacementAlgo==3)
{
  

    // ASSERT(lru_arr[pg1]->val<NumPhysPages);

    int pg1;

//deleted(lru_algo,lru_algo->tail);
        pg1=lru_algo->tail->val;
        deleted(lru_algo,lru_arr[pg1]);
    
 return pg1;
}
else
{
        int i;
        i=*Lru_Start_Pointer;
        // if(p!=-1)
        // {
        //     arr_LruClock[p]=1;
        //     if(i==p)
        //         i==(i+1)%NumPhysPages;
        // }
        while( arr_LruClock[i]==1 || (mainMemoryStatus[i]==-1))
        {
            if((mainMemoryStatus[i]!=-1))
            {
                arr_LruClock[i]=0;
                // i=(i+1)%NumPhysPages;
            }
            i=(i+1)%NumPhysPages;

        }



        if (i==p)
        {
             i=(i+1)%NumPhysPages;

            while( arr_LruClock[i]==1 || (mainMemoryStatus[i]==-1) || i==p)
            {
            if((mainMemoryStatus[i]!=-1))
            {
                arr_LruClock[i]=0;
                // i=(i+1)%NumPhysPages;
            }
            i=(i+1)%NumPhysPages;

        }



        }
        // if (p!=-1)
        // {
        //     arr_LruClock[p]=1;
        // }
        int pg=i;
        *Lru_Start_Pointer=(i+1)%NumPhysPages;
        return pg;


}
    



     
}

// int *add1 = (int *)fifoQueue->Remove();
    // // printf("Removed %d\n",*add1);
    // int pg = *add1;

    // if (pg==p)
    // {

        
    //     int *add2=(int *)fifoQueue->Remove();
    //     pg=*add2;
    //     // printf("Removed %d %d %d\n",*add1,*add2,pg);
    //     delete add2;
    //         List *tempQueue = new List;

    //         tempQueue->Append((void *)add1);

    //         while (!(fifoQueue->IsEmpty()))
    //         {
    //              int *add1 = (int *)fifoQueue->Remove();
    //              tempQueue->Append((void *)add1);
    //         }
    //         while (!(tempQueue->IsEmpty()))
    //         {
    //              int *add1 = (int *)tempQueue->Remove();
    //             fifoQueue->Append((void *)add1);
    //         }



    // }
    // else
    // {
    //     printf("Removed %d\n",*add1);
    // }

    //delete add1;

// if (lru_algo->tail->val==p)
    // {
    //     int val1=lru_algo->tail->val;
    //     deleted(lru_algo,lru_algo->tail);
    //     insertd(lru_algo,lru_arr[val1]);
    //     pg1=lru_algo->tail->val;
    //     deleted(lru_algo,lru_algo->tail);
    // }
    // else
    // {
    //     int pg1=lru_algo->tail->val;
    //     deleted(lru_algo,lru_algo->tail);

    // }






//RANDOM


// int pg=Random()%NumPhysPages;
    // while (pg==p || mainMemoryStatus[pg]==-1)
    // {
    //   pg=Random()%NumPhysPages;
    // }





// EXTRA
 // pg = (int)fifoQueue->Remove();  // Satvik
    // int *x = new int();
    // *x = pg;
    // fifoQueue->Append((void *)x);
    // if(pg==3)
    // {
    //     while (!(fifoQueue->IsEmpty()))
    // {
    //     int *add1 = (int *)fifoQueue->Remove();
    //     // if (thread != NULL)    // make thread ready, consuming the V immediately
    //     // scheduler->ReadyToRun(thread);
    //     printf("address is %d\n",*add1);
        
    // }
    // }   
    // printf("pg is %d\n",pg);
